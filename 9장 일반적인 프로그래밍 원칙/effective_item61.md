# 아이템 61: 박싱된 기본 타입보다는 기본 타입을 사용하라.  
![wrapper](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F246082455852152906FAE7)  

기본 타입과 박싱된 기본 타입의 주된 차이는 크게 세가지다.  
1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다.  
    * 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별 될 수 있다.  
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다.  
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.  

```java
Comparator<Integer> naturalOrder = 
    (i,j) -> (i < j) ? -1 : ( i==j ? 0 : 1);
```  
naturalOrder.compare(new Integer(42), new Integer(42))의 값을 출력해 보자. 두 Integer 인스턴스의 값이 42로 같으므로 0을 출력해야 하지만, 실제로는 1을 출력한다.  
원인이 뭘까 ? i와 j가 참조하는 오토박싱된 Integer 인스턴스는 기본 타입 값으로 변환된다.  
그런 다음 두번째 ( i == j ) 검사가 이뤄진다. 그런데 이 두 번째 검사에서는 두 '객체 참조'의 식별 성을 검사 하게 된다. 
![hashcode_equals](https://ifh.cc/g/7Jg6r.png)  

(같은 객체를 비교하는게 아니라면 ) **박싱된 기본 타입에 == 연산자를 사용 하면 오류가 일어난다.**  
기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.  
```java
public static void main(String[] args) {
    Long sum = 0L
    for (long i = 0 ; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}
```  
이 프로그램은 실수로 지역변수 sum을 박싱된 기본 타입으로 선언하여 느려졌다. 오류나 경고 없이 컴파일 되지만, 박싱과 언박싱이 반복해서 일어나 체감될 정도로 성능이 느려졌다.  

*박싱된 기본 타입은 언제 써야 하는가?*  
1. 컬렉션의 원소, 키, 값으로 쓴다. 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야만 한다.  
2. 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용 해야 한다.  

> 정리 
기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라.  
오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애 주지는 않는다. (두 박싱된 기본 타입을 == 연사자로 비교한다면 식별성 비교가 이뤄지기 때문)  
언박싱 과정에서 NullPointException을 던질 수 있다.  
기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.  
